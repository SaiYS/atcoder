# Path to the test file (Liquid template)
#
# Variables:
#
# - `manifest_dir`: Package directory
# - `contest`:      Contest ID (e.g. "abc100")
# - `bin_name`:     Name of a `bin` target (e.g. "abc100-a")
# - `bin_alias`:    "Alias" for a `bin` target defined in `pacakge.metadata.cargo-compete` (e.g. "a")
# - `problem`:      Alias for `bin_alias` (deprecated)
#
# Additional filters:
#
# - `kebabcase`: Convert to kebab case (by using the `heck` crate)
test-suite = "{{ manifest_dir }}/testcases/{{ bin_alias }}.yml"

# Open files with the command (`jq` command that outputs `string[] | string[][]`)
#
# VSCode:
#open = '[["code", "-a", .manifest_dir], ["code"] + (.paths | map([.src, .test_suite]) | flatten)]'
# Emacs:
#open = '["emacsclient", "-n"] + (.paths | map([.src, .test_suite]) | flatten)'

[template]
src = '''//! This solution is created by SaiYS, @awpsyrhy(Twitter)
#![allow(unused_imports)]

// #[fastout]
fn main() {
    input! {}
    todo!("You can solve it!")
}

use im_rc::{ordmap, ordset, OrdMap, OrdSet};
use itertools::{iproduct, izip, Itertools};
use itertools_num::ItertoolsNum;
use maplit::{btreemap, btreeset, convert_args, hashmap, hashset};
use num::{
    bigint::{BigInt, BigUint, ToBigInt, ToBigUint},
    complex::Complex64,
    integer::{binomial, gcd, gcd_lcm, lcm, multinomial, Integer},
    traits::{abs, abs_sub, Bounded, One, Pow, Saturating, Zero},
};
use proconio::{
    fastout, input,
    marker::{Bytes, Chars, Isize1, Usize1},
    source::{auto::AutoSource, line::LineSource, once::OnceSource},
};
use rand::{random, rngs::SmallRng, Rng};
use std::{
    cmp::{max, min},
    collections::{BTreeMap, BTreeSet, BinaryHeap, VecDeque},
    convert::{From, Into},
    f64::consts::PI,
    str::FromStr,
    string::ToString,
    usize::MAX,
};

pub type HashSet<T> = rustc_hash::FxHashSet<T>;
pub type HashMap<K, V> = rustc_hash::FxHashMap<K, V>;

pub const MOD_1000000007: usize = 1000000007;
pub const MOD_998244353: usize = 998244353;
pub const INF: usize = 2000000000;
pub const FNI: i64 = -2000000000;
pub const ALPHABET_LARGE: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
pub const ALPHABET_SMALL: &str = "abcdefghijklmnopqrstuvwxyz";
pub const ADJ4: [(i64, i64); 4] = [(1, 0), (0, 1), (-1, 0), (0, -1)];
pub const ADJ8: [(i64, i64); 8] = [
    (1, 0),
    (1, 1),
    (0, 1),
    (-1, 1),
    (-1, 0),
    (-1, -1),
    (0, -1),
    (1, -1),
];

use tools::{yn, Visualize, YN};
pub mod tools {
    use itertools::{Iterate, Itertools};
    use std::{
        collections::{BTreeMap, BTreeSet, BinaryHeap, VecDeque},
        fmt::Display,
    };

    pub type HashSet<T> = rustc_hash::FxHashSet<T>;
    pub type HashMap<K, V> = rustc_hash::FxHashMap<K, V>;

    pub fn yn(flag: bool) {
        println!("{}", if flag { "Yes" } else { "No" });
    }

    #[allow(non_snake_case)]
    pub fn YN(flag: bool) {
        println!("{}", if flag { "YES" } else { "NO" });
    }

    #[macro_export]
    macro_rules! vis {
        () => {
            println!();
        };

        ($last:expr ;) => {
            $last.lines();
            vis!()
        };
        ($last:expr =>) => {
            $last.continuous();
            vis!();
        };
        ($last:expr $(,)?) => {
            $last.spaces();
            vis!();
        };

        ($first:expr; $($rest:tt)*) => {
            $first.lines();
            println!();
            vis!($($rest)*);
        };
        ($first:expr => $($rest:tt)*) => {
            $first.continuous();
            vis!($($rest)*);
        };
        ($first:expr, $($rest:tt)*) => {
            $first.spaces();
            print!(" ");
            vis!($($rest)*);
        };
    }

    pub trait Visualize {
        fn visualize(&self, split: &str);
        fn continuous(&self) {
            self.visualize("");
        }
        fn spaces(&self) {
            self.visualize(" ");
        }
        fn lines(&self) {
            self.visualize("\n");
        }
    }

    macro_rules! impl_vis_for_sized {
        ($($t:ty),+) => {
            $(
                impl Visualize for $t {
                    fn visualize(&self, _split: &str) {
                        print!("{}", self);
                    }
                }
            )+
        };
    }

    impl_vis_for_sized! {
        usize, u8, u16, u32, u64, u128,
        isize, i8, i16, i32, i64, i128,
        f32, f64,
        String, &str, char
    }

    impl<T: Display, U: Display> Visualize for (T, U) {
        fn visualize(&self, _split: &str) {
            print!("{} {}", self.0, self.1);
        }
    }

    impl<T: Display, U: Display, V: Display> Visualize for (T, U, V) {
        fn visualize(&self, _split: &str) {
            print!("{} {} {}", self.0, self.1, self.2);
        }
    }

    impl<T: Display, U: Display, V: Display, W: Display> Visualize for (T, U, V, W) {
        fn visualize(&self, _split: &str) {
            print!("{} {} {} {}", self.0, self.1, self.2, self.3);
        }
    }

    impl<T: Display, U: Display, V: Display, W: Display, X: Display> Visualize for (T, U, V, W, X) {
        fn visualize(&self, _split: &str) {
            print!("{} {} {} {} {}", self.0, self.1, self.2, self.3, self.4);
        }
    }

    impl<T: Display> Visualize for [T] {
        fn visualize(&self, split: &str) {
            print!("{}", self.iter().join(split));
        }
    }

    impl<T: Display> Visualize for &[T] {
        fn visualize(&self, split: &str) {
            print!("{}", self.iter().join(split));
        }
    }

    impl<T: Display> Visualize for VecDeque<T> {
        fn visualize(&self, split: &str) {
            print!("{}", self.iter().join(split));
        }
    }

    impl<T: Display> Visualize for BinaryHeap<T> {
        fn visualize(&self, split: &str) {
            print!("{}", self.iter().join(split));
        }
    }

    impl<T: Display> Visualize for HashSet<T> {
        fn visualize(&self, split: &str) {
            print!("{}", self.iter().join(split));
        }
    }

    impl<K: Display, V: Display> Visualize for HashMap<K, V> {
        fn visualize(&self, split: &str) {
            print!(
                "{}",
                self.iter().map(|(k, v)| format!("{} {}", k, v)).join(split)
            );
        }
    }

    impl<T: Display> Visualize for BTreeSet<T> {
        fn visualize(&self, split: &str) {
            print!("{}", self.iter().join(split));
        }
    }

    impl<K: Display, V: Display> Visualize for BTreeMap<K, V> {
        fn visualize(&self, split: &str) {
            print!(
                "{}",
                self.iter().map(|(k, v)| format!("{} {}", k, v)).join(split)
            );
        }
    }
}

'''

[template.new]
# `edition` for `Cargo.toml`.
edition = "2018"
# `profile` for `Cargo.toml`.
#
# By setting this, you can run tests with `opt-level=3` while enabling `debug-assertions` and `overflow-checks`.
#profile = '''
#[dev]
#opt-level = 3
#'''
dependencies = '''
num = "=0.2.1"
num-bigint = "=0.2.6"
num-complex = "=0.2.4"
num-integer = "=0.1.42"
num-iter = "=0.1.40"
num-rational = "=0.2.4"
num-traits = "=0.2.11"
num-derive = "=0.3.0"
ndarray = "=0.13.0"
nalgebra = "=0.20.0"
alga = "=0.9.3"
libm = "=0.2.1"
rand = { version = "=0.7.3", features = ["small_rng"] }
getrandom = "=0.1.14"
rand_chacha = "=0.2.2"
rand_core = "=0.5.1"
rand_hc = "=0.2.0"
rand_pcg = "=0.2.1"
rand_distr = "=0.2.2"
petgraph = "=0.5.0"
indexmap = "=1.3.2"
regex = "=1.3.6"
lazy_static = "=1.4.0"
ordered-float = "=1.0.2"
ascii = "=1.0.0"
permutohedron = "=0.2.4"
superslice = "=1.0.0"
itertools = "=0.9.0"
itertools-num = "=0.1.3"
maplit = "=1.0.2"
either = "=1.5.3"
im-rc = "=14.3.0"
fixedbitset = "=0.2.0"
bitset-fixed = "=0.1.0"
proconio = { version = "=0.3.6", features = ["derive"] }
text_io = "=0.1.8"
whiteread = "=0.5.0"
rustc-hash = "=1.1.0"
smallvec = "=1.2.0"
'''
dev-dependencies = '''
#atcoder-202004-lock = { git = "https://github.com/qryxip/atcoder-202004-lock" }
'''

[template.new.copy-files]
"./template-cargo-lock.toml" = "Cargo.lock"

[new]
kind = "cargo-compete"
# Platform
#
# - atcoder
# - codeforces
# - yukicoder
platform = "atcoder"
# Path (Liquid template)
#
# Variables:
#
# - `contest`:      Contest ID. **May be nil**
# - `package_name`: Package name
path = "./{{ contest }}"

#[new]
#kind = "oj-api"
#url = "https://atcoder.jp/contests/{{ id }}"
#path = "./{{ contest }}"

# for Library-Checker
#[add]
#url = "https://judge.yosupo.jp/problem/{{ args[0] }}"
##is-contest = ["false"] # optional
##target-kind = "bin" # ["bin", "example"]. default to "bin"
#bin-name = '{{ args[0] }}'
##bin-alias = '{{ args[0] }}' # optional
##bin-src-path = './src/bin/{{ bin_alias }}.rs' # optional

# for yukicoder
#[add]
#url = '{% case args[0] %}{% when "contest" %}https://yukicoder.me/contests/{{ args[1] }}{% when "problem" %}https://yukicoder.me/problems/no/{{ args[1] }}{% endcase %}'
#is-contest = ["bash", "-c", '[[ $(cut -d / -f 4) == "contests" ]]'] # optional
##target-kind = "bin" # ["bin", "example"]. default to "bin"
#bin-name = '{% assign segments = url | split: "/" %}{{ segments[5] }}'
##bin-alias = '{% assign segments = url | split: "/" %}{{ segments[5] }}' # optional
##bin-src-path = './src/bin/{{ bin_alias }}.rs' # optional

[test]
# Toolchain for the test. (optional)
toolchain = "1.42.0"
# Profile for `cargo build`. ("dev" | "release")
#
# Defaults to `"dev"`.
#profile = "dev"

[submit.transpile]
kind = "command"
args = [
    "cargo",
    "equip",
    "--exclude-atcoder-crates",
    "--remove",
    "docs",
    "--minify",
    "libs",
    "--bin",
    "{{ bin_name }}",
]
#language_id = ""
